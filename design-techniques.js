// Divide and Conquer: This technique involves breaking a problem down into smaller sub-problems and solving them recursively. It's used in algorithms like merge sort, quick sort, and the Karatsuba algorithm for fast multiplication.

// Dynamic Programming: This technique involves breaking a problem down into smaller sub-problems and storing the solutions to these sub-problems to avoid redundant computation. It's used in algorithms like the Fibonacci sequence, the Longest Common Subsequence, and the Knapsack problem.

// Greedy Algorithms: This technique involves making the locally optimal choice at each step with the hope of finding a global optimum. It's used in algorithms like the Huffman coding, the Kruskal's algorithm for Minimum Spanning Tree, and the Dijkstra's algorithm for shortest path.

// Brute Force: This technique involves checking all possible solutions to a problem and selecting the best one. It's a simple approach but has a high time complexity.

// Backtracking: This technique involves building a solution incrementally by exploring all possible choices and undoing the choices that lead to a dead-end. It's used in algorithms like the N-Queens problem and the Sudoku solver.

// Branch and Bound: This technique involves exploring all possible solutions while keeping track of the best solution found so far. It's used in algorithms like the Traveling Salesman Problem and the Knapsack problem.

// Heuristics: This technique involves using a simple, approximate solution to quickly find a reasonably good solution for a problem.
